# visualizer.sh
A simple music visualizer made using FFMPEG and Bash.

## System requirements
Note: It may be possible to run the script on hardware that doesn't meet these requirements, but you will likely encounter issues.
- A Unix-based operating system.
- 4 GB of available system RAM.
	- If necessary, RAM usage can be reduced by rendering at lower resolutions
- Enough available storage for the dependencies and your rendered videos (expect ~2GB per video).

## Required dependencies
- Bash
- Coreutils
- FFMPEG

## Downloading
Once all dependencies are installed, open a terminal in the directory you wish to install the script into, and run the following command:
```bash
git clone https://github.com/katattakd/visualizer.sh.git
```

## Usage
Run `bash visualizer.sh` an overview of script usage(shown below):
```
Usage: bash visualiser.sh [audio file] (resolution) (volume multiplier) (scroll speed) (sonograph gamma) (bargraph gamma) (audio filter chain) (video filter chain)
```

### Script arguments
- Audio file (required) - Input file for the visualizer to use. Video files are also supported.
- Resolution - Resolution the visualizer is rendered at, defaults to `4096x3072`. Higher resolutions require more RAM and take longer to render, but reveal more detail.
- Volume multiplier (no units) - Allows adjusting the visualizer's sensitivity, in order to make the best use of it's limited dynamic range. Defaults to `28`, and usually doesn't need to be adjusted.
- Scroll speed - Adjusts how quickly the sonograph scrolls, defaults to `1.134`(x). High scroll speeds may fail to render at high resolutions, due to the limitations of the underlying renderer.
- Sonograph/Bargraph gamma - Adjusts how linear/non-linear the bargraph/sonograph scales are. Lower values result in more contrast, while higher values result in more range. Can be any number between `1` and `7`, defaults to `1.26` for the sonograph and `2.38` for the bargraph.
- Audio filter chain - Allows applying FFMPEG filter chains to the visualizer's input audio. Defaults to `loudnorm=dual_mono=true:offset=12`, set to `acopy` to disable filtering.
	- Note: These filters are only applied to to the visualizer's input, the rendered video will have unprocessed audio.
- Video filter chain - Allows applying FFMPEG filter chains to the visualizer's output video. Defaults to `copy` (no filtering).

### Sharing output videos
The output file generated by the script's renders (`output.mkv`) is not suitable for sharing. It's huge (typically ~2GB), very high-resolution, only has a single keyframe (so seeking isn't possible), uses lossless codecs not supported by most video players (lossless YUV444 H.264 video + source audio), and uses a container format that isn't widely supported (Makroska).

As a result of this, you will have to re-encode the output file before you can share it (unless you're trying to share a lossless copy of the rendered video, or you're uploading to a streaming site, such as YouTube, which will re-encode the video for you). There are multiple ways to go about doing this.

The easiest way to do so is by using the script's built-in video compression tool. Simply run `bash compress.sh`, and it will make a compressed version of the output.mkv file called compressed.webm. This does everything right, and results in a high-quality video that you can share with most of your friends.

But, there are some caveats to this:

- It's slow. Expect it to take a while to compress the video.
- You're stuck with specific codecs (yuv420p vp9 + opus), a specific resolution (1080p60), and specific bitrates. If you need wider software support, a higher quality, or a smaller filesize, you'll have to do something else.

As a result of this, you'll likely need to manually compress the output video yourself at some point. Even if uploading to a streaming site / using the built-in tool works fine for now, you may run into a situation in the future when it doesn't.

Here's some guidelines, tips, and potential pitfalls to keep in mind (assuming you know some basic media encoding stuff):

- Make sure to strip out any metadata while re-encoding.
- If you're working with low bitrates (below 1mbit/s), give most of the bitrate to the audio stream. Bad quality audio is much more noticeable than bad quality video.
- If you're uploading to a service which is going to be re-encoding the content (like a streaming site or social media), use lossless codecs if you can, and the highest bitrates possible if you can't.
- Use modern codecs if possible (especially when it comes to the audio), as they'll allow you to get much better quality at the same bitrate.
- Use 60fps if possible, even if it requires lowering the quality a bit more. The visuals benefits a lot from framerates >30fps.
- If filesize/bitrate isn't a huge concern, target a quantizer value (crf) instead of a bitrate. This will allow for more consistent quality between videos.
	- For audio: If lossless isn't an option, use a vbr setting.
